import{V as g,M as _,E as O}from"./Game-CnuxNJ62.js";var w;(a=>{function t(e,n,i,h,f="white"){e.fillStyle=f,e.beginPath(),e.arc(n,i,h,0,2*Math.PI),e.fill()}a.drawCircle=t;function r(e,n,i,h,f,m=3,P="white"){e.beginPath(),e.moveTo(n,i),e.lineTo(h,f),e.lineWidth=m,e.strokeStyle=P,e.lineCap="round",e.stroke()}a.drawLine=r;function l(e,n,i=3,h="white",f=!1){if(n.length<2)throw"lines should have at least 2 points";e.beginPath(),e.moveTo(n[0].x,n[0].y);for(let m=1;m<n.length;m++)e.lineTo(n[m].x,n[m].y);f||e.lineTo(n[0].x,n[0].y),e.lineWidth=i,e.strokeStyle=h,e.lineCap="round",e.stroke()}a.drawLines=l;function u(e,n,i="white"){if(n.length<3)throw"shape should have at least 3 points";e.beginPath(),e.moveTo(n[0].x,n[0].y);for(let h=1;h<n.length;h++)e.lineTo(n[h].x,n[h].y);e.fillStyle=i,e.fill()}a.drawShape=u;function o(e){const n=[];for(let i=0;i<e.length;i++){const h=new g(e[i].x,e[i].y),f=new g(e[(i+1)%e.length].x,e[(i+1)%e.length].y),m=h.sub(f),P=new g(m.y,-m.x).normalize();n.push(P)}return n}a.getNormalsOfConnectedPoints=o;function s(e,n){let i=Number.MIN_VALUE,h=Number.MAX_VALUE;return e.forEach(f=>{const m=Math.abs(n.dot(f));i=i<m?m:i,h=h>m?m:h}),{min:h,max:i}}a.getMinMaxOfPointsOnAxis=s;function d(e,n){if(e.min<n.max&&n.min<e.max){const i=Math.max(e.min,n.min);return Math.min(e.max,n.max)-i}else return 0}a.getMinMaxOverlapLength=d})(w||(w={}));var y;(a=>{function t(o,s,d,e,n="white"){o.fillStyle=n,o.beginPath(),o.arc(s,d,e,0,2*Math.PI),o.fill()}a.drawCircle=t;function r(o,s,d,e,n,i=3,h="white"){o.beginPath(),o.moveTo(s,d),o.lineTo(e,n),o.lineWidth=i,o.strokeStyle=h,o.lineCap="round",o.stroke()}a.drawLine=r;function l(o,s,d=3,e="white",n=!1){if(s.length<2)throw"lines should have at least 2 points";o.beginPath(),o.moveTo(s[0].x,s[0].y);for(let i=1;i<s.length;i++)o.lineTo(s[i].x,s[i].y);n||o.lineTo(s[0].x,s[0].y),o.lineWidth=d,o.strokeStyle=e,o.lineCap="round",o.stroke()}a.drawLines=l;function u(o,s,d="white"){if(s.length<3)throw"shape should have at least 3 points";o.beginPath(),o.moveTo(s[0].x,s[0].y);for(let e=1;e<s.length;e++)o.lineTo(s[e].x,s[e].y);o.fillStyle=d,o.fill()}a.drawShape=u})(y||(y={}));class M{game;constructor(){}}var c;(a=>{function t(l,u){if(u.length<3)throw"amount of points houdl be at least 3";const o=[...u,u[0]],s=o.length;let d=!1;for(let e=0;e<s-1;e++){const n=o[e],i=o[e+1];l.y<n.y!=l.y<i.y&&l.x<(i.x-n.x)*(l.y-n.y)/(i.y-n.y)+n.x&&(d=!d)}return d}a.isPointWithinShape=t;function r(l,u){const o=w.getNormalsOfConnectedPoints(l).concat(w.getNormalsOfConnectedPoints(u));let s=Number.MAX_VALUE,d=new g;for(let e=0;e<o.length;e++){const n=o[e],i=w.getMinMaxOfPointsOnAxis(l,n),h=w.getMinMaxOfPointsOnAxis(u,n),f=w.getMinMaxOverlapLength(i,h);if(f===0)return null;s>f&&(s=f,d=new g(o[e].x*f,o[e].y*f))}return d}a.checkSasCollisionOnPolygons=r})(c||(c={}));var v;(a=>{a.DoDrawAsPolygon=!0,a.SimulationTimeStep=.001,a.Gravity=9.80665})(v||(v={}));class C extends M{_points=[];_color="white";constructor(t,r="White"){super(),this._points=t,this._color=r}transformation=new _(1,0,0,0,1,0,0,0,1);move(t){this.transformation.translate(t.x,t.y)}rotate(t){this.transformation.rotate(t)}getTransformedPoints(){return this._points.map(t=>new g(t.x,t.y).applyMatrix3(this.transformation))}getMidAvgPoint(){const t=this.getTransformedPoints(),r=new g;return t.forEach(l=>[r.add(l)]),r.divide(new g(t.length,t.length))}draw(t){const r=this.getTransformedPoints();v.DoDrawAsPolygon?(y.drawLines(t,r,2,this._color),r.forEach(l=>{y.drawCircle(t,l.x,l.y,5,this._color)})):y.drawShape(t,r,this._color)}visible=!0}class T extends C{centerOrigin(){const t=new g;this._points.forEach(l=>t.add(l));const r=new g(t.x/this._points.length,t.y/this._points.length);this._points.forEach(l=>{l.sub(r)}),this.transformation.translate(r.x,r.y)}resetTransoform(){this.transformation=new _(1,0,0,0,1,0,0,0,1)}_originalColor="white";constructor(t,r="White"){super(t,r),this._originalColor=r}update(t){if(this.isPressed===!0){const r=this.game?._MouseController.getMouseDelta();this.move(this.isPressed?r||new g(0,0):new g(0,0))}}onPress(){}onUnpress(){}isPressed=!1;onClick(){this._color="yellow",new Promise(t=>setTimeout(t,200)).then(()=>{this._color=this._originalColor})}mouseOnState=!1;onHover(){this._color="red"}onUnHover(){this._color=this._originalColor}isHoveredOver=!1;isMouseOn(t){const r=this.getTransformedPoints();return c.isPointWithinShape(t,r)}draw(t){this.isHoveredOver&&(this._color="red"),this.isPressed&&(this._color="green"),super.draw(t),this._color=this._originalColor}}class b extends M{_Color;constructor(t,r=3,l="white"){super(),this.position=t,this._radius=r,this._Color=l}rotate(t){throw new Error("Method not implemented.")}position;rotation=new O;_radius=1;visible=!0;move(t){this.position.add(t)}draw(t){y.drawCircle(t,this.position.x,this.position.y,this._radius,this._Color)}}export{c as A,w as C,y as D,M as G,T as M,b as P};
